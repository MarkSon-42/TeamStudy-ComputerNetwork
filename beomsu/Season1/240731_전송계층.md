## Pipelined Protocols

**설명:**
파이프라인 프로토콜은 네트워크 통신에서 데이터 패킷을 연속적으로 전송하여 효율성을 극대화하는 기법입니다. 단일 패킷의 전송-응답 주기를 기다리지 않고 여러 패킷을 동시에 보내는 방식으로, 네트워크 대역폭을 최적화하고 전송 속도를 높이는 데 사용됩니다. 파이프라인 프로토콜의 대표적인 예는 슬라이딩 윈도우(sliding window) 기법입니다.

- 간단설명
    
    ### Go-Back-N (GBN) 프로토콜
    
    **기본 개념:**
    
    - Go-Back-N은 파이프라인 프로토콜의 한 종류로, 송신자가 N개의 패킷을 연속적으로 전송할 수 있도록 합니다.
    - 수신자는 순차적으로 패킷을 수신하고 확인 응답(ACK)을 보내며, 중간에 손실된 패킷이 있으면 해당 패킷 이후의 모든 패킷을 다시 요청합니다.
    
    **작동 방식:**
    
    1. 송신자는 최대 N개의 패킷을 연속적으로 전송합니다.
    2. 각 패킷에 대해 수신자로부터 ACK를 기다립니다.
    3. 만약 특정 패킷이 손실되면, 그 이후의 모든 패킷도 무효가 되어 송신자는 손실된 패킷부터 다시 전송합니다.
    
    **예시:**
    
    - 송신자가 패킷 1, 2, 3, 4, 5를 연속적으로 보냅니다.
    - 패킷 3이 손실되면, 수신자는 패킷 4와 5를 버리고 송신자에게 패킷 3부터 다시 보내달라고 요청합니다.
    - 송신자는 패킷 3, 4, 5를 다시 보냅니다.
    
    ### Selective Repeat (SR) 프로토콜
    
    **기본 개념:**
    
    - Selective Repeat도 파이프라인 프로토콜의 한 종류로, 송신자가 N개의 패킷을 연속적으로 전송할 수 있습니다.
    - Go-Back-N과 달리, Selective Repeat는 손실된 패킷만 다시 요청하고, 나머지 패킷은 유지합니다.
    
    **작동 방식:**
    
    1. 송신자는 최대 N개의 패킷을 연속적으로 전송합니다.
    2. 각 패킷에 대해 수신자로부터 ACK를 기다립니다.
    3. 특정 패킷이 손실되면, 수신자는 손실된 패킷만 다시 요청하고, 이미 수신한 패킷은 유지합니다.
    
    **예시:**
    
    - 송신자가 패킷 1, 2, 3, 4, 5를 연속적으로 보냅니다.
    - 패킷 3이 손실되면, 수신자는 패킷 3만 다시 보내달라고 요청합니다.
    - 송신자는 패킷 3만 다시 보냅니다.
    - 수신자는 패킷 1, 2, 4, 5는 그대로 유지하고, 패킷 3을 다시 받아 모든 패킷을 순서대로 조립합니다.
    
    ### 비교
    
    - **Go-Back-N:**
        - 간단하고 구현이 용이하지만, 손실된 패킷 이후의 모든 패킷을 다시 보내야 하므로 비효율적입니다.
        - 송신자가 패킷 손실 후 N개의 패킷을 다시 전송해야 하므로 대역폭을 낭비할 수 있습니다.
    - **Selective Repeat:**
        - 좀 더 복잡하지만, 손실된 패킷만 다시 전송하므로 대역폭을 효율적으로 사용할 수 있습니다.
        - 수신자가 패킷을 순서대로 저장하고 조립하는 추가적인 버퍼링이 필요합니다.
    
    ### 요약
    
    - **Pipelined 프로토콜**은 여러 패킷을 동시에 전송하여 효율성을 높이는 방법입니다.
    - **Go-Back-N**은 손실된 패킷 이후의 모든 패킷을 다시 전송하는 방식으로 구현이 간단하지만 비효율적입니다.
    - **Selective Repeat**는 손실된 패킷만 다시 전송하는 방식으로 더 효율적이지만 구현이 복잡합니다.

### Go-Back-N (GBN)

**설명:**
Go-Back-N은 파이프라인 프로토콜의 한 형태로, 송신자가 여러 패킷을 연속적으로 보내고, 수신자가 순서대로 패킷을 확인하는 방식입니다. 특정 윈도우 크기 내에서 여러 패킷을 송신할 수 있으며, 수신자가 ACK(인증) 패킷을 보낼 때까지 송신자는 해당 윈도우 내의 패킷을 다시 송신하지 않습니다.

**작동 방식:**

1. 송신자는 설정된 윈도우 크기만큼 패킷을 연속적으로 전송합니다.
2. 수신자는 각 패킷에 대한 ACK를 송신자에게 보냅니다.
3. ACK가 올바르게 도착하면 송신자는 윈도우를 이동하고 새로운 패킷을 전송합니다.
4. 만약 패킷이 손실되거나 오류가 발생하면, 수신자는 해당 패킷 이후의 모든 패킷을 무시하고 송신자는 손실된 패킷부터 다시 전송합니다.

**장단점:**

- **장점:** 구현이 간단하며, 순차적으로 패킷을 재전송하므로 신뢰성이 높습니다.
- **단점:** 패킷 손실 시 대량의 재전송이 필요하여 효율성이 떨어질 수 있습니다.

### Selective Repeat (SR)

**설명:**
Selective Repeat는 Go-Back-N과 유사하지만, 손실되거나 오류가 발생한 패킷만 선택적으로 재전송하는 방식입니다. 이를 통해 불필요한 재전송을 줄이고 전송 효율성을 높입니다.

**작동 방식:**

1. 송신자는 설정된 윈도우 크기만큼 패킷을 연속적으로 전송합니다.
2. 수신자는 각 패킷에 대한 ACK를 송신자에게 보냅니다.
3. 손실되거나 오류가 발생한 패킷에 대해서만 수신자는 NACK(부인)을 보내거나 ACK를 보내지 않습니다.
4. 송신자는 수신자로부터 ACK를 받지 못한 패킷만 재전송합니다.

**장단점:**

- **장점:** 효율성이 높고, 불필요한 재전송을 줄일 수 있습니다.
- **단점:** 구현이 복잡하며, 수신 측에서 더 큰 버퍼가 필요합니다

## TCP flow control

### TCP Flow Control 설명

**기본 개념:**

- 수신자가 송신자에게 자신의 수신 윈도우 크기(RcvWindow)를 알립니다.
- 송신자는 이 값을 기반으로 데이터 전송 속도를 조절합니다.
- 이를 통해 송신자는 수신자가 감당할 수 있는 양의 데이터만 전송하여 버퍼 오버플로를 방지합니다.

### 작동 원리

TCP 흐름 제어는 수신 윈도우(Receive Window)라는 개념을 통해 이루어집니다. 이 과정은 다음과 같습니다:

1. **초기 설정:**
    - TCP 연결이 설정될 때, 수신자는 자신의 버퍼 크기를 송신자에게 알립니다.
    - 예를 들어, 수신자의 버퍼 크기가 10KB라면, 송신 윈도우 크기(RcvWindow)를 10KB로 설정합니다.
2. **데이터 전송:**
    - 송신자는 수신자가 설정한 윈도우 크기 내에서 데이터를 전송합니다.
    - 예를 들어, 수신 윈도우 크기가 10KB라면, 송신자는 10KB 이하의 데이터를 전송할 수 있습니다.
3. **ACK와 윈도우 업데이트:**
    - 수신자가 데이터를 수신하고 처리하면, ACK 패킷을 송신자에게 보냅니다.
    - 이 ACK 패킷에는 현재 남아있는 수신 윈도우 크기가 포함되어 있습니다.
    - 송신자는 수신자로부터 받은 윈도우 크기 정보를 바탕으로 다음 데이터를 전송할 수 있는 양을 결정합니다.
4. **동적 조절:**
    - 수신 윈도우 크기는 동적으로 조절될 수 있습니다. 예를 들어, 수신자가 데이터를 빠르게 처리할 수 있으면 윈도우 크기를 늘리고, 처리 속도가 느려지면 윈도우 크기를 줄일 수 있습니다.

### 예시를 통한 설명

**예시:**

- 당신의 컴퓨터(송신자)가 서버(수신자)에게 파일을 전송하고 있습니다.
- 서버의 버퍼 크기는 10KB로 설정되어 있습니다.

**과정 설명:**

1. **초기 설정:**
    - 서버는 TCP 연결이 설정될 때 자신의 버퍼 크기(10KB)를 송신자에게 알립니다.
    - 송신자는 한 번에 최대 10KB의 데이터를 전송할 수 있습니다.
2. **데이터 전송:**
    - 송신자는 10KB의 데이터를 서버로 전송합니다.
    - 서버는 이 데이터를 수신하고, 버퍼에 저장합니다.
3. **ACK와 윈도우 업데이트:**
    - 서버는 데이터를 처리한 후, 송신자에게 ACK 패킷을 보냅니다.
    - 이 패킷에는 현재 남아있는 수신 윈도우 크기 정보가 포함되어 있습니다. 예를 들어, 서버가 5KB의 데이터를 처리했다면, 남아있는 수신 윈도우 크기는 5KB입니다.
4. **동적 조절:**
    - 송신자는 ACK 패킷에 포함된 윈도우 크기 정보를 확인하고, 다음 데이터를 전송할 양을 결정합니다.
    - 만약 수신 윈도우 크기가 5KB로 줄어들었다면, 송신자는 최대 5KB의 데이터를 전송합니다.

### 요약

TCP 흐름 제어는 송신자가 수신자가 감당할 수 있는 속도로 데이터를 전송하도록 조절하는 중요한 메커니즘입니다. 이는 수신 윈도우 크기를 통해 이루어지며, 네트워크의 안정성과 효율성을 유지합니다. 송신자는 수신자로부터 받은 윈도우 크기 정보를 바탕으로 데이터 전송 속도를 동적으로 조절하여, 수신자의 버퍼가 넘치지 않도록 합니다.

## Congestion Control

### TCP 혼잡 제어 3단계

1. **Slow Start (느린 시작)**
    
    **예시:**
    
    - 당신이 친구에게 편지를 보내기로 했어요. 처음에는 편지를 한 장씩 보내기로 해요.
    
    **과정 설명:**
    
    - **처음에는** 한 번에 한 장의 편지만 보낼 수 있습니다. (cwnd = 1)
    - **매번 편지가 도착하면** 친구가 "다음 편지 주세요!"라고 응답해줍니다. 그래서 다음 편지를 더 많이 보낼 수 있게 됩니다.
    - **편지가 잘 도착하면** 매번 편지를 두 배로 보내기 시작합니다. 예를 들어, 첫 번째 RTT에는 1장, 두 번째 RTT에는 2장, 세 번째 RTT에는 4장, 네 번째 RTT에는 8장 이렇게 보내요.
    - 이렇게 계속해서 편지를 두 배씩 보내면서 네트워크의 용량을 확인해요.
    
    **목표:** 네트워크가 얼마나 빠른지, 얼마나 많은 편지를 보낼 수 있는지 알아보는 단계입니다.
    
2. **Additive Increase (선형 증가)**
    
    **예시:**
    
    - 이제 네트워크가 안정적이라고 생각하고, 더 많은 편지를 보내기로 해요. 예를 들어, 한 번에 16장까지 보낼 수 있게 되었어요.
    
    **과정 설명:**
    
    - **cwnd가 ssthresh에 도달하면** (예를 들어, 16장), 이제부터는 매번 편지를 한 장씩 더 보내기로 해요.
    - 처음에는 16장, 다음 RTT에는 17장, 그 다음에는 18장, 19장, 20장… 이렇게 조금씩 늘려가요.
    
    **목표:** 네트워크가 안정적인 상태를 유지하면서 조금씩 더 많은 데이터를 보내는 단계입니다.
    
3. **Multiplicative Decrease (곱셈 감소)**
    
    **예시:**
    
    - 그런데, 갑자기 편지를 보내던 도중에 일부 편지가 도착하지 않아서 친구가 "편지 일부가 손실됐어요!"라고 말해요.
    
    **과정 설명:**
    
    - **패킷 손실이 발생하거나 타임아웃이 발생하면** (예를 들어, 20장 중 5장이 도착하지 않았어요), 네트워크가 혼잡하다고 판단하고, 전송 속도를 급격히 줄이기로 해요.
    - **cwnd를 절반으로 줄이고** (예를 들어, 20장에서 10장으로), 다시 한 장씩 보내면서 네트워크 상태를 확인해요.
    - 이렇게 함으로써 네트워크가 과부하되지 않도록 조절해요.
    
    **목표:** 네트워크가 혼잡해졌을 때, 빠르게 속도를 줄여서 네트워크가 다시 안정적인 상태로 돌아가도록 하는 단계입니다.
    

## TCP Fairness

- TCP 공정성은 네트워크 상에서 여러 TCP 연결이 동시에 존재할 때, 각 연결이 대역폭을 공정하게 나누어 사용하는 것을 목표로 합니다.
- 혼잡 제어 알고리즘을 통해 각 연결이 네트워크 상태를 인지하고, 혼잡이 발생하지 않도록 전송 속도를 조절합니다.

syn bit
3way hand shake
rdtp

## 3way hand shake

### TCP 3-Way Handshake 과정

TCP 3-Way Handshake는 클라이언트와 서버가 연결을 설정하기 위해 세 번의 메시지를 주고받는 과정을 의미합니다. 이 과정을 통해 클라이언트와 서버는 서로의 동작을 확인하고, 연결을 안정적으로 설정할 수 있습니다. 각 단계는 다음과 같습니다:

### 1. **SYN (Synchronize) 단계**

- **클라이언트:** 연결 요청을 보내기 위해 TCP 패킷을 전송합니다.
    - 이 패킷의 SYN 플래그 비트를 1로 설정합니다.
    - 이 패킷에는 클라이언트의 초기 시퀀스 번호(Seq Number)가 포함됩니다.

**예시 메시지:**

```arduino
arduino코드 복사
Client -> Server: SYN, Seq = x

```

여기서 `x`는 클라이언트의 초기 시퀀스 번호입니다.

### 2. **SYN-ACK (Synchronize-Acknowledge) 단계**

- **서버:** 클라이언트의 SYN 패킷을 수신하고, 응답으로 SYN-ACK 패킷을 전송합니다.
    - SYN 플래그와 ACK 플래그를 모두 1로 설정합니다.
    - 이 패킷에는 서버의 초기 시퀀스 번호(Seq Number)와 클라이언트의 ACK 번호가 포함됩니다.

**예시 메시지:**

```arduino
arduino코드 복사
Server -> Client: SYN, ACK, Seq = y, Ack = x + 1

```

여기서 `y`는 서버의 초기 시퀀스 번호, `x + 1`은 클라이언트의 시퀀스 번호에 1을 더한 값입니다.

### 3. **ACK (Acknowledge) 단계**

- **클라이언트:** 서버의 SYN-ACK 패킷을 수신하고, 연결 수립의 확인을 위해 ACK 패킷을 전송합니다.
    - ACK 플래그만 1로 설정합니다.
    - 이 패킷에는 클라이언트의 ACK 번호가 서버의 시퀀스 번호 + 1로 설정됩니다.

**예시 메시지:**

```arduino
arduino코드 복사
Client -> Server: ACK, Ack = y + 1

```

여기서 `y + 1`은 서버의 시퀀스 번호에 1을 더한 값입니다.

### 전체 과정 요약

1. **클라이언트가 서버에 SYN 패킷을 전송합니다.**
2. **서버가 SYN-ACK 패킷으로 응답합니다.**
3. **클라이언트가 ACK 패킷을 전송하여 연결을 완료합니다.**
