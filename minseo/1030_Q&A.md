# 전송 계층 (Transport Layer) 기술 면접 Q&A

1. Q: 흐름제어와 혼잡제어가 무엇인가요? 
   A: [흐름제어]
   수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생깁니다. 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 됩니다. 즉, 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법입니다. 
   
   [혼잡제어] 
   데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못합니다. 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 합니다. 이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방할 수 있는데, 이것을 혼잡 제어라고 합니다. 

 

2. Q: 흐름제어와 혼잡제어를 하는 방법이 뭐가있을까요?  
   A: [흐름제어] 
   1. Stop and wait 
   매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법입니다. 그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법입니다. 
   2. sliding window
   수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법입니다. 최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변합니다. 예를 들면, 송신자는 수신자의 확인 응답을 받기 전까지 데이터를 보내고 수신자 확인 응답을 송신자에게 보내면, 슬라이딩 윈도우 사이즈를 충족할 수 있게끔 윈도우를 옆으로 옮깁니다. 

   [혼잡제어]
   1. AIMD(Additive Increase / Multiplicative Decrease)
   처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법입니다. 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄이는 방식입니다.  
   2. Slow Start (느린 시작)
   윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식입니다. 이후 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킵니다.
   3. Fast Recovery (빠른 회복)
   혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법입니다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 됩니다.

3. Q: Cookie , Session에 대해서 설명해주세요
   A: [쿠키]
   쿠키는 클라이언트의 브라우저에 설치되는 작은 기록 정보 파일입니다. 

   1. 브라우저가 서버에 요청을 보냅니다.
   2. 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답 헤더의 Set-Cookie에 담습니다.
   3. 이후 해당 클라이언트는 요청을 보낼 때마다, 매번 저장된 쿠키를 요청 헤더의 Cookie에 담아 보냅니다. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별하거나 정보를 바탕으로 추천 광고를 띄우거나 합니다.

   단점은 브라우저에 정보를 저장하기 때문에 보안에 취약합니다. 

   [세션]
   세션은 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리합니다. 
   
   1. 유저가 웹사이트에서 로그인하면 세션이 서버 메모리(혹은 데이터베이스) 상에 저장되며 세션을 식별하기 위한 Session Id를 기준으로 정보를 저장합니다. 
   2. 서버에서 브라우저에게 Session Id를 보내주고 쿠키에다가 Session Id를 저장합니다. 
   3. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송합니다.
   4. 서버는 클라이언트가 보낸 Session Id 와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행합니다.

   서버에 저장되어 보안이 뛰어나지만  서버에서 세션 저장소를 사용하므로  요청이 많아질 수록 서버에 부하가 심해집니다. 

4. Q: Restful API가 무엇인가요? 
   A: 자원을 URI 로 표시하고 해당 자원의 상태를 주고 받는 것을 의미합니다. 즉, Rest는 URI를 통해 자원을 표시하고, HTTP METHOD를 이용하여 해당 자원의 행위를 정해주며 그 결과를 받는 것을 의미하는데요. Restful API 이란 REST를 REST 답게 쓰는 것을 의미하며, 만약 CRUD 기능을 전부 POST METHOD로만 처리한다면 Restful 하지 못하다고 표현합니다. 

5. Q: GET 메서드와 POST 메서드의 차이점에 대해 설명해주세요.
   A: [GET]
   GET은 데이터를 조회할 때 사용하는 메소드로, URL 파라미터에 요청하는 데이터를 담아 보내기 때문에  HTTP 요청 메시지의 BODY부분이 비어있습니다.

   [POST]
   POST는 데이터를 생성할 때 사용하는 메소드로 데티어 전송 시 HTTP 요청 메시지의 BODY부분에 데이터를 저장하여 전송합니다. 
   
   GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같기 때문에 멱등이며, POST는 리소스 생성/업데이트 용도이기 때문에 멱등이 아닙니다. 
   * 멱등: 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질 의미

6. Q: 웹 서버와 웹 어플리케이션 서버에 대해 차이를 중점으로 설명하세요.
   A: 웹 서버는 HTTP 요청을 받아 정적인 웹 페이지 형태로 응답을 처리해 반환하는 프로그램입니다. 반면 웹 어플리케이션 서버는 사용자 요구사항에 맞는 다양한 로직을 처리하여 동적 컨텐츠를 제공하는 역할을 합니다. 처리 속도를 위해 정적인 처리는 웹 서버를 통해 하고, 동적인 처리는 웹 어플리케이션 서버가 담당합니다.

- 참고 : https://baebalja.tistory.com/443

7. Q: www.naver.com에 접속할 때 생기는 과정에 대해 설명해주세요. (웹 동작 방식 이해)
   A: 
   1. 사용자가 브라우저에 URL(www.naver.com)을 입력
   2. DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음
   3. IP 주소로 웹 서버에 TCP 3 handshake로 연결 수립
   4. 클라이언트는 웹 서버로 HTTP 요청 메시지를 보냄
   5. 웹 서버는 HTTP 응답 메시지를 보냄
   6. 도착한 HTTP 응답 메세지는 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력

8. Q: 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요.
   A: 공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP주소 입니다.
   사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소부족으로 인해 서브넷팅된 IP이기 때문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.
   사설 IP 주소만으로는 인터넷에 직접 연결할 수 없고, 라우터를 통해 1개의 공인 IP를 할당하고, 라우터에 연결된 개인 PC는 사설 IP를 각각 할당 받아 인터넷에 접속 할 수 있습니다.

- 출처: https://dev-coco.tistory.com/161 [슬기로운 개발생활:티스토리]


